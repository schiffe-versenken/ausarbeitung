% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
\documentclass[a4paper,12pt]{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\makeindex

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}      % Code-Page latin 1
\usepackage[T1]{fontenc}
% Nur eine der beiden folgenden Zeilen einbinden!
% siehe Abschnitt Bilder
%\usepackage{graphicx}       % Bilder einbinden, Version fuer normales latex
\usepackage[pdftex]{graphicx}       % Bilder einbinden, Version fuer pdflatex

% mit Hyperrefs
\usepackage[pdftex, plainpages=false,hypertexnames=true,pdfnewwindow=true,backref=true,colorlinks=true,citecolor=blue,linkcolor=black,urlcolor=blue,filecolor=blue]{hyperref}% 
% weitere Packages
\usepackage{ifthen}                 % Zum Auskommentieren von Textteilen
\usepackage{amssymb}                % Mathematische Buchstaben
\usepackage{amsmath}                % Verbesserter Formelsatz
\usepackage[vlined,boxed]{algorithm2e}
\usepackage{booktabs}               % schönere Tabellen
\usepackage{color}
\usepackage{hyperref}
 \hypersetup{urlcolor=black,citecolor=black}

%\setalcapskip{1.5ex} % fuer package algorithm
\usepackage{dsfont}  
%\newtheorem{definition}{Definition}
\usepackage{doc}
\usepackage{mathrsfs}

% Seitenformat ===============================================================
\hoffset=-1.25truecm
\setlength{\topmargin}{0.0cm}
\setlength{\textheight}{23.0cm}
\setlength{\footskip}{1.5cm}
\setlength{\textwidth}{15.4cm}
\setlength{\evensidemargin}{1.5cm}
\setlength{\oddsidemargin}{1.5cm}
\setlength{\parskip}{1ex}
\setlength{\parindent}{0pt}
\setlength{\marginparwidth}{1.4cm}
\setlength{\marginparsep}{1mm}

\pagestyle{plain}

% Makro-Definitionen ==========================================================

% 
\def\myverzeichnis{.}

\numberwithin{equation}{section} 
% Bild -----------------------------------------------------------------------
% #1 Filename;  #2 Label;  #3 Bildunterschrift;  #4 Kurzform
\newcommand{\bild}[4]{
  \begin{figure}[htbp]
    \begin{center}
      \includegraphics{#1}
      \caption[#4]{#3}
      \label{#2}
    \end{center}
  \end{figure}
}

% Bildbreite -----------------------------------------------------------------
% #1 Filename;  #2 Breite;  #3 Label;  #4 Bildunterschrift;  #5 Kurzform
\newcommand{\bildbreite}[5]{
  \begin{figure}[htbp]
    \begin{center}
      \includegraphics[width=#2]{#1}
      \caption[#5]{#4}
      \label{#3}
    \end{center}
  \end{figure}
}

\newtheorem{satz}{Satz}
\newtheorem{korollar}{Korollar}


% ============================================================================
\begin{document}

% =========== Das war der Vorspann, jetzt geht's los! ========================

% ============================================================================
% =============  AB HIER DARF UND SOLL GETIPPT WERDEN ========================
% ============================================================================
\author{Viel Schreiber}
\index{Viel Schreiber}

% Das Institut wird fuer den Betreuer missbraucht ...
\institute{{\bf Betreuer:} Dipl.-Inf. Carl Coder}
\authorrunning{Viel Schreiber}
\title{Meine Seminarausarbeitung}

\maketitle

\thispagestyle{empty}

\begin{abstract}
Ein schöner Abstract. Das ist einfach die Kurzzusammenfassung.
\end{abstract}

[Christopher]

% Einleitung -----------------------------------------------------------------
\section{Einleitung}

\subsection{Spielbeschreibung}
Diese Ausarbeitung beschäftigt sich mit der Umsetzung von Schiffe-Versenken in beliebig viele Dimensionen.
Die generelle Funktionsweise von dem normalen Schiffe-Versenken bleibt erhalten, muss jedoch um einige Dinge erweitert werden, um auch in höheren Dimensionen gut spielbar zu sein.

Wir betrachten das Spielgeschehen zur Einfachheit halber nur aus der Sicht eines Spielers.
Zu Beginn platziert der Gegner eine feste und bekannte Anzahl an Schiffen auf seinem Spielfeld. Es wird davon ausgegangen, dass die Schiffspositionen rein zufällig ausgewählt wurden. (Hier mehr Details mit Permutation)
Natürlich sind die Schiffspositionen dem Spieler nicht bekannt.
Die Gesamtheit aller gewählten Schiffspositionen wird auch die Flotte genannt.
Nun kann der Spieler anfangen, auf bestimmte Positionen auf dem Spielfeld, auch Zellen genannt, zu schießen.
Nach jedem Schuss erfährt der Spieler von seinem Gegner, die Anzahl an getroffenen Schiffen.
Falls keine Schiffe getroffen wurden ist die Anzahl 0.
Da Schiffe überlappen können, kann die Anzahl auch größer als 1 sein.
Sobald alle Schiffe versenkt wurden, ist das Spiel beendet.

Das Ziel des Spielers ist es, mit möglichst wenig Schüssen alle Schiffe zu versenken.

%\bildbreite{figures/einleitung.jpg}{15cm}{Einleitung}{Bild}{as}

\subsection{Inhalt}
Zu Beginn wird das beschriebene Spielprinzip formalisiert, sodass man damit mathematisch arbeiten kann.

Anschließend werden verschiedene Spielstrategien vorgestellt.

Danach werden verschiedene Möglichkeiten präsentiert, die Spielstrategien so gut wie möglich zu optimieren, damit sie auch mit sehr vielen Dimensionen immernoch effizient berechenbar sind.

Zum Schluss werden dann die Strategien mithilfe der vorherigen Kenntnisse implementiert und die Ergebnisse in Bezug auf Laufzeiteffizienz verglichen.

\section{Formalisierung des Spielprinzips}

\begin{definition}
Sei $C_{all}=\{1, \dots, N\}^d$ die Menge aller Zellen (cells) des Spielfeldes mit jeweils $N$ Zellen in $d$ Dimensionen.
\end{definition}

\begin{definition}
Sei
\[
F=(c_{min}, c_{max})
\]
eine mögliche Schiffsposition (location), welche mithilfe einer minimalen Ecke $c_{min} \in C_{all}$ und einer maximalen Ecke $c_{max} \in C_{all}$ bestimmt wird.
\end{definition}

\begin{definition}
Sei $F=(c_{min}, c_{max})$ eine mögliche Schiffsposition.
Dann ist
\[
cells(F)=
\{
c
\in
C
\mid
c_{min} \leq c \leq c_{max}
\}
\]
die Menge aller Zellen, welche sich innerhalb der möglichen Schiffsposition $F$ befinden.
\end{definition}

\begin{definition}
Sei 
\[
F_{all}=
\{
\{
k
\in
C_{all}
\mid
i \leq k \leq j
\}
\mid
i,j \in C_{all}
\wedge
i \leq j
\}
\] die Menge aller möglichen Schiffspositionen.
\end{definition}

\begin{definition}
Sei $ship\_count$ die Anzahl der platzierten Schiffe.
\end{definition}

\begin{definition}
Sei $F_{all}=\{F \subseteq F_{all} \mid |F|=ship\_count\}$ die Menge von allen möglichen Flotten, die der Gegner auf dem Spielfeld platzieren kann.
\end{definition}

\begin{definition}
Sei $F_a \in F_{all}$ die vom Gegner auf dem Spielfeld platzierte Flotte.
Da diese geheim ist, wird sie in der restlichen Ausarbeitung auch als unbekannt angesehen.
\end{definition}

\begin{definition}
Sei
\[
H=\{0, \dots, ship\_count\}
\]
die Menge an theoretisch möglichen Trefferanzahlen bei einem Schuss auf eine Zelle.
\end{definition}

\begin{definition}
Sei $F \in F_{all}$ und $c \in C_{all}$.
Dann ist 
\begin{align}
&hit:F_{all} \times C_{all} \rightarrow H \quad mit \nonumber\\
&hit(F, c)=|\{F \in F_{all} \mid c \in cells(F)\} \cap F|  \nonumber
\end{align}
die Treffer-Funktion, welche angibt, wie viele Schiffe bei einem Schuss auf Zelle $c$ getroffen wurden, falls $F$ die vom Gegner platzierte Flotte ist. In anderen Worten, die Anzahl der Schiffe aus Flotte $F$, die die Zelle $c$ belegen.
\end{definition}

\begin{definition}
Sei $c \in C_{all}$.
Dann ist 
\[
hit(c)=hit(F_a, c)
\]
eine Kurzform. Die Funktionswerte sind ebenfalls unbekannt, da $F_a$ geheim ist. Also wird auch diese Funktion in der restlichen Ausarbeitung auch als unbekannt angesehen.
\end{definition}

\subsection{Zustände}

In dem Zustand werden alle Informationen über alle vorherigen Schüsse gespeichert.
Dies sind die beschossenen Zellen und jeweils getroffenen Schiffe.

\begin{definition}
Sei
\[
S_{all}=\mathscr{P}(C_{all}\times H)
\]
die Menge aller möglichen Zustände.

Ein Zustand der Form $S=\{(c_1, h_1), \dots , (c_k, h_k)\}\in S_{all}$ ist dann der Zustand nach $k$ Schüssen.
Das heißt, die Reihenfolge der einzelnen Schüsse spielt hier keine Rolle, da ein Zustand nur eine Menge an Tupeln ist.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ der momentane Zustand.
Dann ist
\begin{align}
C_{shot}(S)=\{c \in C_{all} \mid (c,h) \in S, \; h \in H\}
\end{align}
 die Menge an Zellen, auf die bereits geschossen wurde.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ der momentane Zustand.
Dann ist 
\begin{align}
C_{left}(S)=C_{all} \setminus C_{shot}(S)
\end{align}
die Menge an Zellen, auf die noch nicht geschossen wurde.
\end{definition}

\begin{definition}
Sei
\begin{align}
&fire:F_{all}\times S_{all}\times P(C_{all}) \rightarrow S_{all} \quad mit \nonumber\\
&fire(F, S, cells)=S \cup \{(cell,hit(F, cell)) \mid cell \in cells\}  \nonumber
\end{align}
die Schuss-Funktion, welche die Zellen und die jeweiligen Treffer dem Zustand $S$ hinzufügt.
\end{definition}

\begin{definition}
Sei
\begin{align}
&hypo\_fire:S_{all}\times P(C_{all}\times H) \rightarrow S_{all} \quad mit \nonumber\\
&hypo\_fire(S, cell\_hits)=hypo\_fire(S, \{(c_1,h_1), \dots, (c_k, h_k)\})=S \cup cell\_hits \nonumber
\end{align}
die hypothetische Schuss-Funktion, welche den Zustand so verändert, als hätte es $h_i$ Treffer bei dem Schuss auf Zelle $c_i$ gegeben. Es werden also keine echten Schüsse abgegeben, es wird angenommen, dass ein Schuss auf Zelle $c_i$mit $h_i$ Treffern abgegeben wird.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
fleets(S)=\{F\in F_{all} \mid \forall (c,h) \in S \colon hit(F, c)=h\}
\]
die Menge aller Flotten, auf die die Treffer-Informationen vom Zustand $S$ zutreffen.
In anderen Worten, die Menge an zum Zustand $S$ noch möglichen Flotten.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
fleet\_count(S)=|fleets(S)|
\]
\end{definition}


\begin{satz}
Sei $S\in S_{all}$ ein Zustand.
Sei außerdem $F \in fleets(S)$ eine mögliche Flotte.

Dann ist
\[
P(F = F_a \mid S)=\frac{1}{fleet\_count(S)}
\]
die Wahrscheinlichkeit, dass $F$ die richtige Flotte zum Zustand $S$ ist.
\end{satz}

\begin{proof}
TODO
Es gilt:
\begin{align}
P(F=F_a\mid S)&= \frac{1}{\left|fleets(S)\right|} \nonumber\\
 &= \frac{1}{fleets\_count(S)}\nonumber
\end{align}
\end{proof}


\begin{satz}
Sei $S\in S_{all}$ ein Zustand.
Seien außerdem $shots \in P(C_{left}(S) \times H)$ die beschossenen Zellen und Trefferangaben.
Dann ist
\[
P(hit(c)=h \mid S)=\frac{fleet\_count(hypo\_fire(S, shots))}{fleet\_count(S)}
\]
\end{satz}
die Wahrscheinlichkeit zu dem Zustand $S$, dass bei dem Schuss auf Zelle $c$ genau $h$ Schiffe getroffen werden.

\begin{proof}
Vor dem Schuss gibt es noch im Zustand $S$ genau $fleet\_count(S)$ mögliche Flotten.
Nach dem Schuss gibt es nur noch \\$fleet\_count(hypo\_fire(S,c, h))$ mögliche Flotten.
\end{proof}


\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
C_{undetermined}(S)=\{ c \in C_{left}(S) \mid \nexists h \in H \colon P(hit(c)=h \mid S) \in \{0, 1\}\}
\]
die Menge an allen Zellen, auf welche noch nicht geschossen wurde und noch nicht genau feststeht, wie viele Schiffe bei einem Schuss darauf getroffen werden.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
determined(S) \Leftrightarrow fleet\_count(S)=1 \Leftrightarrow C_{undetermined}(S) = \emptyset
\]
wahr gdw. die richtige Flotte bereits bestimmt ist.
\end{definition}


\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
C_{left\_to\_finish}(S)=\{ c \in C_{left}(S) \mid \exists h \in H \colon P(hit(c)=h \mid S) = 1\}
\]
die Menge an allen Zellen, auf welche noch nicht geschossen wurde und genau feststeht, wie viele Schiffe bei einem Schuss darauf getroffen werden.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
finished(S) \Leftrightarrow determined(S) \land C_{left\_to\_finish}(S) = \emptyset
\]
wahr gdw. alle Schiffe zerstört wurden.
\end{definition}

\subsection{Schuss-Strategien}

\begin{definition}
Eine Funktion der Form
\begin{align}
&strat:S_{all} \times C_{all} \rightarrow \mathbb{R} \nonumber
\end{align}
wird Strategiefunktion genannt. Diese weißt zu einem Zustand einer Zelle einen Wert zu, d.h. sie bewertet, wie gut sich jede Zelle als nächstes Schussziel eignet.
\end{definition}

\begin{definition}
Sei
\[
strategies=\{ strat:S_{all} \times C_{all} \rightarrow \mathbb{R} \}
\]
die Menge an allen gültigen Strategiefunktionen.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Sei außerdem $strat \in strategies$ die verwendete Schuss-Strategie.
Sei $C \subseteq C_{undetermined}(S)$ eine Menge an Zellen.
Dann ist
\[
max\_value=\max strat(S, C)
\]
der maximale Wert, den die Strategiefunktion über allen Zellen ausgibt.

Dann ist
\begin{align}
&best\_cell:S_{all} \times P(C) \times strategies \rightarrow C \quad mit \nonumber\\
&best\_cell(S, C, strat)=x \in \{c \in C \mid strat(S, c) = max\_value\}
\nonumber
\end{align}
eine Funktion, welche die nach der Strategiefunktion $strat$ besten Zelle aus der Menge $C$ auswählt.
\end{definition}

\subsection{Ziel-Funktionen}

\begin{definition}
Sei
\begin{align}
&target:S_{all} \times strategies \rightarrow P(C_{all}) \quad mit \nonumber\\
&target(S,strat)=
\begin{cases}
C_{left\_to\_finish}(S)&, determined(S) \\
\{best\_cell(S, strat, C_{undetermined}(S))\}&, sonst
\end{cases}
\nonumber
\end{align}
die Ziel-Funktion, welche die Menge an Zellen bestimmt, auf die als nächstes geschossen werden soll.
\end{definition}


\begin{definition}
Sei $F\in F_{all}$ die gewählte Flotte und $S\in S_{all}$ der momentane Zustand.
Sei außerdem $strat \in S$ die verwendete Schuss-Strategie.
Dann ist
\begin{align}
&shot\_count(F, S, strat)=\\
& \begin{cases} 
  	|C_{left\_to\_finish}(S)|& ,determined(S) \\
      shot\_count(F, fire(F, S, best\_cell(S, strat, C_{undetermined}(S))), strat) + 1 & ,sonst
   \end{cases}
\nonumber
\end{align}
die Anzahl an Schüssen, die von der Ziel-Funktion benötigt werden, um alle Schiffe der bereits bekannten Flotte mit der Schuss-Strategiefunktion $strat$ zu versenken.
\end{definition}

\subsection{Algorithmus}

Somit kann nun ein einfacher Algorithmus formuliert werden, der mithilfe einer festgelegten Strategie versucht, alle Schiffe zu versenken:

\begin{algorithm}[H]
 function solve(strat):\\
 $S=\emptyset$\;
 $shot\_count=0$\;
 \While{$\neg finished(S)$}{
  $next\_targets=target(S, strat)$\;
  $S=fire(S, next\_targets)$\;
  $shot\_count=shot\_count+|next\_targets|$\;
 }
\end{algorithm}

Dieser Algorithmus bestimmt in jedem Schritt das beste Schussziel und zählt zusätzlich mit, vieviele Schüsse er abgegeben hat.

\section{Greedy-Strategien}

\subsection{Greedy-Hit-Strategie}
Die Greedy-Hit-Strategie versucht bei jedem Schuss die erwartete Anzahl an getroffenen Schiffen zu maximieren.

\begin{definition}
Sei $c \in C_{undetermined}(S)$ die beschossene Zelle.
Dann ist
\[
H_{c}=hit(c)
\]
eine Zufallsvariable, die die Anzahl an Treffern bei einem Schuss auf Zelle $c$ angibt.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand und $c \in C_{undetermined}(S)$ die beschossene Zelle.
Dann ist
\[
P_S(H_{c}=h)=P(hit(c)=h \mid S) 
\]
die Wahrscheinlichkeit, $h$ Schiffe zum Zustand $S$ bei einem Schuss auf Zelle $c$ zu treffen.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand und $c \in C_{undetermined}(S)$ die beschossene Zelle.
Dann ist
\[
\mathds{E}_S(hit(c))=\sum_{h \in H} P_S(H_{c}=h) * h
\]
die erwartete Anzahl an getroffenen Schiffen im Zustand $S$ bei einem Schuss auf $c$.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
strat_{greedy-hit}(S,c)=\mathds{E}_S(hit(c))
\]
die Greedy-Hit-Strategie.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
V_S^{H_{c}}(i)=P_S(H_{c} \leq i)
\]
die Verteilungsfunktion von $P_S(H_{c}=h)$.
\end{definition}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
I(c)=\sum_{i=0}^{ship\_count - 1} V_S^{H_{c}}(i)=\int_{0}^{ship\_count} V_S^{H_{c}}(x) dx
\]
\end{definition}

\begin{satz}
Sei $S\in S_{all}$ der momentane Zustand.
Sei außerdem $c \in C_{left}(S)$ die beschossene Zelle.
Dann ist
\begin{align}
\begin{split}
&\mathds{E}(H_{F,c})=ship\_count - I(S,c)
\end{split}
\end{align}
\end{satz}

\begin{proof}
\begin{align}
\begin{split}
&\mathds{E}_S(H_{c})\\
=&\sum_{h=1}^{ship\_count} P_S(H_{c} \geq h)\\
=&\sum_{h=1}^{ship\_count} P_S(H_{c}=h) + P_S(H_{S,c} > h)\\
=&\sum_{h=1}^{ship\_count} P_S(H_{c}=h) + (1 - P_S(H_{c} \leq h)\\
=&P_S(H_{c} > 0) + \sum_{h=1}^{ship\_count} (1 - P_S(H_{c} \leq h)\\
=&1 - V_S^{H_{c}}(0) + ship\_count - \sum_{h=1}^{ship\_count} P_S(H_{c} \leq h)\\
=&1 - V_S^{H_{c}}(0) + ship\_count - \sum_{h=1}^{ship\_count} V_S^{H_{c}}(h)=\\
=&1 + ship\_count - \sum_{h=0}^{ship\_count} V_S^{H_{c}}(h)=\\
=&ship\_count - \sum_{h=0}^{ship\_count - 1} V_S^{H_{c}}(h)=\\
=&ship\_count - \int_{0}^{ship\_count} V_S^{H_{c}}(h) \; dh\\
=&ship\_count - I(S,c)\\
\end{split}
\end{align}
\qed
\end{proof}

\subsection{Greedy-fleet-Strategie}
Die Greedy-fleet-Strategie versucht bei jedem Schuss die erwartete Anzahl an ausgeschlossenen Flotten zu maximieren.

\begin{definition}
Sei $S\in S_{all}$ der momentane Zustand.
Sei außerdem $c \in C_{undetermined}(S)$ die beschossene Zelle.
Dann ist
\[
fleets\_removed(F, S, c)=fleet\_count(S) - fleet\_count(fire(F, S,c))
\]
die Anzahl an Flotten, die nach diesem Schuss ausgeschlossen werden könnten.
\end{definition}

\begin{satz}
Sei $S\in S_{all}$ der momentane Zustand.
Sei außerdem $c \in C_{left}(S)$ die beschossene Zelle.
Dann ist
\begin{align}
\begin{split}
&\mathds{E}(fleets\_removed(S,c))=\\
&\frac{1}{fleet\_count(S)} * \sum_{F \in fleets(S)} fleets\_removed(F, S, c) \nonumber
\end{split}
\end{align}
\end{satz}

\begin{proof}
Definition des Erwartungswertes.
\end{proof}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
strat_{greedy-fleet}(S,c)=\mathds{E}(fleets\_removed(S,c))
\]
die Greedy-fleet-Strategie.
\end{definition}


\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\[
Q(S,c)=\sum_{h \in H} P_S(H_{c}=h)^2
\]
\end{definition}

\begin{satz}
Sei $S\in S_{all}$ der momentane Zustand.
Sei außerdem $c \in C_{left}(S)$ die beschossene Zelle.
Dann ist
\begin{align}
\begin{split}
\mathds{E}(fleet\_count(fire(S,\{c\})))=fleet\_count(S)\; Q(S,c)
\end{split}
\end{align}
\end{satz}

\begin{proof}
\begin{align}
\begin{split}
&\mathds{E}(fleet\_count(fire(S,\{c\})))\\
=&\sum_{h \in H} P_S(H_{c} = h) * fleet\_count(hypo\_fire(S,\{(c,h)\}))\\
=&\sum_{h \in H} \frac{fleet\_count(hypo\_fire(S,\{(c,h)\}))}{fleet\_count(S)}* fleet\_count(hypo\_fire(S,\{(c,h)\}))\\
=&\frac{1}{fleet\_count(S)} * \sum_{h \in H} fleet\_count(hypo\_fire(S,\{(c,h)\}))^2\\
=&\frac{1}{fleet\_count(S)} * \sum_{h \in H} (P_S(H_{c} = h) * fleet\_count(S))^2\\
=&fleet\_count(S) * \sum_{h \in H} P_S(H_{c} = h)^2\\
=&fleet\_count(S) * Q(S,c)\\
\end{split}
\end{align}
\qed
\end{proof}

\begin{satz}
Sei $S\in S_{all}$ der momentane Zustand.
Sei außerdem $c \in C_{left}(S)$ die beschossene Zelle.
Dann ist
\begin{align}
\begin{split}
&\mathds{E}(fleets\_removed(S,c))\\
=&fleet\_count(S) (1 - Q(S,c))
\end{split}
\end{align}
\end{satz}

\begin{proof}
\begin{align}
\begin{split}
&\mathds{E}(fleets\_removed(S,c))\\
=&\mathds{E}(fleet\_count(S) - fleet\_count(fire(S,c)))\\
=&fleet\_count(S) - \mathds{E}(fleet\_count(fire(S,\{c\})))\\
=&fleet\_count(S) - (fleet\_count(S)\; Q(S,c))\\
=&fleet\_count(S) (1 - Q(S,c))
\end{split}
\end{align}
\end{proof}

\subsection{Vergleich der Strategien}
Auf den ersten Blick sieht es aus, dass die beiden vorgestellten Greedy-Strategien zwei verschiedene Definitionen für die gleiche Strategie sind. Im vorherigen Abschnitt wurde aber gezeigt, dass sich beide Strategien unterscheiden.

Daraus folgt, dass beide Werte von unterschiedlichen Eigenschaften der Wahrscheinlichkeitsverteilung von $P(hit(c)=h \mid S)$ abhängen. Daher ist die genaue Korrelation zwischen ausgeschlossenen Flotten und getroffenen Schiffen für jede Zelle individuell, da die Wahrscheinlichkeitsverteilung von $P(hit(c)=h \mid S)$ individuell ist. Für manche Zellen, können beide Strategien äquivalent sein, aber für andere Zellen kann auch eine inverse Korrelation bestehen und mit vielen Treffern gleichzeitig wenig Flotten ausgeschlossen werden.

Mithilfe des Wissens, von was diese zwei verschiedenen Werte abhängen, können jetzt ganz leicht Gegenbeispiele konstruiert werden, in denen beide Strategien unterschiedliche Zellen auswählen.


\section{Optimale-Strategie}

AB HIER NOCH SEHR UNFERTIG

Um eine optimale Schuss-Strategie zu definieren, werden ein paar Definitionen benötigt, um den Begriff `Optimal` zu definieren.

\subsection{Definition von Optimalität}

\begin{satz}
Sei $S\in S_{all}$ der momentane Zustand und $strat \in S$ die verwendete Schuss-Strategie.
Dann ist
\[
\mathds{E}(shot\_count(S, strat))=\frac{1}{fleet\_count(S)} * \sum_{F \in fleets(S)}{shot\_count(F, S, strat)}
\]
die erwartete Anzahl an Schüssen, die benötigt werden, um alle Schiffe zu versenken.
\end{satz}

\begin{proof}
\begin{align}
\mathds{E}(shot\_count(S, strat))=\\
\sum_{F \in fleets(S)}{P(F_a= F \mid S) * shot\_count(F, S, strat)} =\\
\frac{1}{fleet\_count(S)} * \sum_{F \in fleets(S)}{shot\_count(F, S, strat)}
\end{align}
\qed
\end{proof}

Nun kann definiert werden, was es für eine Strategie heißt, optimal zu sein:
\begin{definition}
Eine Strategiefunktion $strat \in S$ heißt optimal, falls gilt:
\[
\forall strat_{alt} \in S \colon \mathds{E}(shot\_count(S, strat)) \leq \mathds{E}(shot\_count(S, strat_{alt}))
\]
\end{definition}

\subsection{Herleitung}

\begin{definition}
Sei $S\in S_{all}$ ein Zustand.
Dann ist
\begin{align}
\begin{split}
strat_{opt}(S, c)=\mathds{E}(shot\_count(S, c, strat_{opt}))
\end{split}
\end{align}
die optimale Strategiefunktion.
Diese wählt für den Zustand $S$ eine Zelle aus, welche nach Beschuss die Anzahl an benötigten Schüssen um alle Schiffe zu versenken, minimiert.
\end{definition}


\begin{lemma}
Sei $S\in S_{all}$ der momentane Zustand, $c\in C_{all}$ die Zelle, auf die geschossen werden soll und $strat \in S$ die verwendete Schuss-Strategie.
Dann ist
\[
\mathds{E}(shot\_count(S, c, strat))=\mathds{E}(shot\_count(fire(S, \{c\}), strat)) + 1
\]
die erwartete Anzahl an Schüssen, die benötigt werden, um alle Schiffe zu versenken, falls der nächste Schuss auf Zelle $c$ abgefeuert wird.
\end{lemma}

\begin{proof}
Trivial
\end{proof}



\begin{satz}[Optimalität]
Sei $strat_{opt}$ die optimale Strategiefunktion und $strat_{alt} \in S$ eine andere Strategiefunktion.
Dann gilt:
\[
\mathds{E}(shot\_count(S, strat_{opt})) \leq \mathds{E}(shot\_count(S, strat_{alt}))
\]
\end{satz}

\begin{proof}
TODO
\begin{align}
\begin{split}
&\mathds{E}(shot\_count(S, strat_{opt}))\\
=&\mathds{E}(shot\_count(S, best\_cell(S, C_{undetermined}(S), strat_{opt}), strat_{opt})) + 1\\
=&\min_{c \in C_{undetermined}(S)} \mathds{E}(shot\_count(S, c, strat_{opt})) + 1\\
\leq & \mathds{E}(shot\_count(S, c_{other}, strat_{opt})), c_{other} \in C_{undetermined}(S)\\
\Rightarrow &\mathds{E}(shot\_count(S, strat_{opt})) \leq \mathds{E}(shot\_count(S, strat_{alt}))
\end{split}
\end{align}
\qed
\end{proof}

\subsection{Berechnung}


TODO

\begin{algorithm}[H]
 function determinants(F, fleets):\\
 $determinants=\emptyset$\;
 \For{$S \in P(finished\_states(F))$}{
   is\_determinant=true\;
   \For{$F_{other} \in fleets \setminus \{F\}$}{
     \If{$S \subseteq finished\_node(F_{other})$}{
       $is\_determinant=false$\;
       break\;
     }
    }
    \If{is\_determinant}{
      $determinants = determinants \cup \{S\}$\;
    }
 }
 \Return determinants\;
\end{algorithm}

\begin{algorithm}[H]
 function create\_end\_nodes($S_{start}$):\\
 $nodes=\emptyset$\;
 \For{$F \in fleets(S_{start})$}{
   \For{$S \in determinants(F)$}{
     \If{$S_{start} \subseteq S$}{
        $x=(\{F\}, S, |C_{left\_to\_finish}(S)|)$\;
        $nodes=nodes \cup x$\;
      }
    }
 }
  \Return nodes\;
\end{algorithm}

\newpage

\begin{algorithm}[H]
 function calculate\_expected\_shots($S_{start}$):\\
 $nodes=create\_end\_nodes(fleets(S))$\;
 $transitions[S,c,h]=\emptyset$\;
 $transitions\_cells[S]=\emptyset$\;
 $results = \emptyset$\;
 \While{$nodes \neq \emptyset$}{
 $previous\_states=\emptyset$\;
 \For{$x \in nodes$}{
   \For{$(c,h) \in (state(S) \setminus S_{start})$}{
    $S=state(x) \setminus \{(c,h)\}$\;
    $previous\_states=previous\_states \cup S$\;
    $previous\_fleets[S]=previous\_fleets \cup fleets(x)$\;
    $transition\_cells[S]=transition\_cells[S] \cup \{c\}$\;
    $transitions[S,c,h]=transitions[S,c,h] \cup x$\;
    }
 }
 
 $new\_nodes=\emptyset$\;
  \For{$S \in previous\_states$}{
    $\mathds{E}_{min}=\infty $\;
    \For{$c \in transition\_cells[S]$}{
      $\mathds{E}_{c}=\sum_{h \in H} \frac{|fleets(transitions[S,c,h])|}{|previous\_fleets[S]|} * expected(transitions[x,c,h])$\;
      
      \If{$S = S_{start}$}{
       $results = results \cup \{(c,\mathds{E}_{c})\}$\;
      }
      
      \If{$\mathds{E}_{c} < \mathds{E}_{min}$}{
       $\mathds{E}_{min}=\mathds{E}_{c}$\;
      }
    }
    $new\_nodes = new\_nodes \cup \{(previous\_fleets[S], S, \mathds{E}_{min} + 1)\}$\;
 }
 $nodes = new\_nodes$\;
 }

  \Return results\;
\end{algorithm}


\begin{algorithm}[H]
 function $strat_{opt}(S_{start}, c$):\\
    \If{$(c,e) \in calculate\_expected\_shots(S_{start}), e \in \mathds{R}$}{
     \Return $-e$\;
   }
   \Return $\infty$ \;
\end{algorithm}






\newpage

\section{Optimierungen}

Wir nähern uns langsam der Implementation der Schuss-Strategien.
Um die Laufzeit der Implementation möglichst klein zu halten, werden in diesem Kapitel eine Reihe von Optimierungsmethoden vorgestellt.

\subsection{Berechnung von Schiffspositionen}
\begin{definition}
Sei $C_{pos} \subseteq C_{shot}(S)$ eine Teilmenge der beschossenen Zellen.
Sei außerdem $C_{neg}=C_{shot}(S) \setminus C_{pos}$.

Dann heißt
\[
s=(C_{pos}, C_{neg})
\]
ein Schuss-Schnitt.
\end{definition}

\begin{definition}
Sei $s=(C_{pos}, C_{neg})$ ein Schuss-Schnitt.

Dann heißt $s$ zusammenhängend, wenn gilt:
\[
\exists d \in D \colon \forall n \in C_{neg} \colon (\forall p \in C_{pos} \colon n_d \leq p_d) \lor (\forall p \in C_{pos} \colon n_d \geq p_d)
\]
\end{definition}

\begin{satz}
Sei $s=(C_{pos}, C_{neg})$ ein Schuss-Schnitt.

Dann gilt:
\[
location\_count(S, X) > 0 \Leftrightarrow X ist zusammenhängend \land \forall c \in C_{pos} \colon hit(S,c) > 0
\]
\end{satz}

\begin{proof}
\end{proof}

\begin{definition}
Sei
\[
coherent\_cuts=\{s \mid s ist zusammenhängend\}
\]
die Menge aller zusammenhängenden Schnitte.
\end{definition}

\begin{definition}
Eine Box $b$ wird von $c$ verdeckt, falls gilt:
\[
\forall d \in D \colon (cell(b)_d < c_d \land \forall p \in C_{pos} \colon c_d \leq p_d) \lor (cell(b)_d > c_d \land \forall p \in C_{pos} \colon c_d \geq p_d)
\]

Sei $C_{pos}$ eine Menge an Zellen, die belegt werden sollen. Sei außerdem $C_{neg}$ eine Menge an Zellen, die nicht belegt werden sollen.

Dann ist
\[
location\_count(C_{pos}, C_{neg})
\]
die Anzahl der möglichen Schiffspositionen $F \in F_{all}$ für die gilt: $C_{pos} \subseteq cells(F)$ und $C_{neg} \cap cells(F) = \emptyset$.
\end{definition}

\subsection{Berechnung der Verteilungsanzahl mit Verteilungsfunktionen}[Christopher]

In allen vorherigen Berechnungen wird nur die Anzahl an Flotten zum Zustand $S$, fleet\_count(S), benötigt, da es zu jedem Zustand eine Gleichverteilung an Flotten gibt.

Der naive Ansatz diesen Wert zu berechnen, wäre alle Verteilungen zu konstruieren und dann zusammen zu zählen.
Mithilfe den sogenannten Verteilungsfunktionen und ein bischen Kombinatorik lässt sich die Anzahl einfacher berechnen.

\begin{definition}
Sei $cell\_combinations(S)=\mathcal{P}(C_{shot}(S))$.
\end{definition}

\begin{definition}
Sei $comb \in cell\_combinations(S)$. Dann ist
\[
location\_count(S,comb)=location\_count(comb, C_{shot}(S) \setminus comb)
\]
eine Kurzform.
\end{definition}

\begin{definition}
Sei $comb \in cell\_combinations(S)$. Dann ist
\[
max\_shared\_ship\_count(S,comb)=\min\{location\_count(S, comb)\} \cup \{h \mid (c,h) \in S \wedge c \in comb\}
\]
\end{definition}

\begin{definition}
Sei
\[
hit\_count(S, c, s)=\sum_{comb \in \{x \in cell\_combinations(S) \mid c \in x\}}{s(comb)}
\]
\end{definition}

\begin{definition}
Sei
\begin{align}
\begin{split}
sha&re\_functions(S)=\{s \colon cell\_combinations(S) \rightarrow \mathbb{N}_0 \mid\\
&\forall{(c,h) \in S}\colon hit\_count(S, c, s)=h \wedge \\
&\forall{comb \in cell\_combinations(S)} \colon 0 \leq s(comb) \leq max\_shared\_ship\_count(S, comb)\\
\}\;\;\;& \nonumber
\end{split}
\end{align}
die Menge an Share-Funktionen, die das LGS (...) lösen.
\end{definition}

\begin{satz}
Sei $S\in S_{all}$ der momentane Zustand und $s \in share\_functions(S)$ eine Verteilungsfunktion.
Dann ist
\[
fleet\_count(S, s)=
\left( \prod_{comb \in cell\_combinations(S)}{{location\_count(S, comb)\choose s(comb)}} \right)
\]
die Anzahl an möglichen Flotten für die Verteilungsfunktion $s$.
\end{satz}

\begin{proof}
Für jede Teilkombination $comb \in cell\_combinations_S$ gibt es $location\_count_S(comb)$ Positionen, die genau die Zellen der Teilkombination belegen. Aus diesen Positionen werden dann mit der Funktion $s_S$ genau $s_S(comb)$ Positionen für Schiffe ausgewählt. Daher gibt es für jede Teilkombination ${location\_count_S(comb)\choose s_S(comb)}$ verschiedene Schiffspositionen.

Die gesamte Anzahl an möglichen Flotten ergibt sich dann einfach aus der Multiplikation der Anzahl an Schiffspositionen der einzelnen Teilkombinationen.
\end{proof}

\begin{definition}
Sei
\[
fleet\_count(S)=\sum_{s \in share\_functions(S)}{fleet\_count(s)}
\]
\end{definition}

Joel und Samuel:

\section{Implementierung der Strategien}

\section{Vergleich der Strategien}


% Literaturverzeichnis ------------------------------------------------
\newpage
\bibliographystyle{alphadinLinkLocal}
\bibliography{literatur} 

%\iffalse
\end{document}
%\fi
